// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: submissions.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submissions (
    problem_id,
    user_id,
    language,
    source_code,
    status
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id, problem_id, user_id, language, source_code, status, updated_at, created_at
`

type CreateSubmissionParams struct {
	ProblemID  uuid.UUID
	UserID     uuid.UUID
	Language   int32
	SourceCode string
	Status     string
}

func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRowContext(ctx, createSubmission,
		arg.ProblemID,
		arg.UserID,
		arg.Language,
		arg.SourceCode,
		arg.Status,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.UserID,
		&i.Language,
		&i.SourceCode,
		&i.Status,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createSubmissionResult = `-- name: CreateSubmissionResult :one
INSERT INTO submission_results (
    id,
    submission_id,
    judge_token,
    stdin,
    stdout,
    expected_output,
    status_id,
    time_used,
    memory_used,
    judge_response
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) RETURNING id, submission_id, judge_token, stdin, stdout, expected_output, status_id, time_used, memory_used, judge_response, updated_at, created_at
`

type CreateSubmissionResultParams struct {
	ID             uuid.UUID
	SubmissionID   uuid.UUID
	JudgeToken     string
	Stdin          string
	Stdout         string
	ExpectedOutput string
	StatusID       int32
	TimeUsed       string
	MemoryUsed     float64
	JudgeResponse  []byte
}

func (q *Queries) CreateSubmissionResult(ctx context.Context, arg CreateSubmissionResultParams) (SubmissionResult, error) {
	row := q.db.QueryRowContext(ctx, createSubmissionResult,
		arg.ID,
		arg.SubmissionID,
		arg.JudgeToken,
		arg.Stdin,
		arg.Stdout,
		arg.ExpectedOutput,
		arg.StatusID,
		arg.TimeUsed,
		arg.MemoryUsed,
		arg.JudgeResponse,
	)
	var i SubmissionResult
	err := row.Scan(
		&i.ID,
		&i.SubmissionID,
		&i.JudgeToken,
		&i.Stdin,
		&i.Stdout,
		&i.ExpectedOutput,
		&i.StatusID,
		&i.TimeUsed,
		&i.MemoryUsed,
		&i.JudgeResponse,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createSubmissionResults = `-- name: CreateSubmissionResults :many
INSERT INTO submission_results (
    id,
    submission_id,
    judge_token,
    stdin,
    stdout,
    expected_output,
    status_id,
    time_used,
    memory_used,
    judge_response
) 
VALUES (
    gen_random_uuid(),
    $1,
    unnest($2::text[]),    
    unnest($3::text[]),    
    unnest($4::text[]),   
    unnest($5::text[]),
    unnest($6::integer[]),
    unnest($7::text[]),
    unnest($8::float8[]),
    unnest($9::bytea[])
)
RETURNING id, submission_id, judge_token, stdin, stdout, expected_output, status_id, time_used, memory_used, judge_response, updated_at, created_at
`

type CreateSubmissionResultsParams struct {
	SubmissionID    uuid.UUID
	Tokens          []string
	Stdins          []string
	Stdouts         []string
	Expectedoutputs []string
	Statuses        []int32
	Times           []string
	Memories        []float64
	Responses       [][]byte
}

func (q *Queries) CreateSubmissionResults(ctx context.Context, arg CreateSubmissionResultsParams) ([]SubmissionResult, error) {
	rows, err := q.db.QueryContext(ctx, createSubmissionResults,
		arg.SubmissionID,
		pq.Array(arg.Tokens),
		pq.Array(arg.Stdins),
		pq.Array(arg.Stdouts),
		pq.Array(arg.Expectedoutputs),
		pq.Array(arg.Statuses),
		pq.Array(arg.Times),
		pq.Array(arg.Memories),
		pq.Array(arg.Responses),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubmissionResult
	for rows.Next() {
		var i SubmissionResult
		if err := rows.Scan(
			&i.ID,
			&i.SubmissionID,
			&i.JudgeToken,
			&i.Stdin,
			&i.Stdout,
			&i.ExpectedOutput,
			&i.StatusID,
			&i.TimeUsed,
			&i.MemoryUsed,
			&i.JudgeResponse,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionByID = `-- name: GetSubmissionByID :one
SELECT id, problem_id, user_id, language, source_code, status, updated_at, created_at FROM submissions WHERE id = $1
`

func (q *Queries) GetSubmissionByID(ctx context.Context, id uuid.UUID) (Submission, error) {
	row := q.db.QueryRowContext(ctx, getSubmissionByID, id)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.UserID,
		&i.Language,
		&i.SourceCode,
		&i.Status,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSubmissionResultByID = `-- name: GetSubmissionResultByID :one
SELECT id, submission_id, judge_token, stdin, stdout, expected_output, status_id, time_used, memory_used, judge_response, updated_at, created_at FROM submission_results WHERE id = $1
`

func (q *Queries) GetSubmissionResultByID(ctx context.Context, id uuid.UUID) (SubmissionResult, error) {
	row := q.db.QueryRowContext(ctx, getSubmissionResultByID, id)
	var i SubmissionResult
	err := row.Scan(
		&i.ID,
		&i.SubmissionID,
		&i.JudgeToken,
		&i.Stdin,
		&i.Stdout,
		&i.ExpectedOutput,
		&i.StatusID,
		&i.TimeUsed,
		&i.MemoryUsed,
		&i.JudgeResponse,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSubmissionResultsBySubmissionID = `-- name: GetSubmissionResultsBySubmissionID :many
SELECT id, submission_id, judge_token, stdin, stdout, expected_output, status_id, time_used, memory_used, judge_response, updated_at, created_at FROM submission_results WHERE submission_id = $1 OFFSET $2 LIMIT $3
`

type GetSubmissionResultsBySubmissionIDParams struct {
	SubmissionID uuid.UUID
	Offset       int32
	Limit        int32
}

func (q *Queries) GetSubmissionResultsBySubmissionID(ctx context.Context, arg GetSubmissionResultsBySubmissionIDParams) ([]SubmissionResult, error) {
	rows, err := q.db.QueryContext(ctx, getSubmissionResultsBySubmissionID, arg.SubmissionID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubmissionResult
	for rows.Next() {
		var i SubmissionResult
		if err := rows.Scan(
			&i.ID,
			&i.SubmissionID,
			&i.JudgeToken,
			&i.Stdin,
			&i.Stdout,
			&i.ExpectedOutput,
			&i.StatusID,
			&i.TimeUsed,
			&i.MemoryUsed,
			&i.JudgeResponse,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByProblemID = `-- name: GetSubmissionsByProblemID :many
SELECT id, problem_id, user_id, language, source_code, status, updated_at, created_at FROM submissions WHERE problem_id = $1 OFFSET $2 LIMIT $3
`

type GetSubmissionsByProblemIDParams struct {
	ProblemID uuid.UUID
	Offset    int32
	Limit     int32
}

func (q *Queries) GetSubmissionsByProblemID(ctx context.Context, arg GetSubmissionsByProblemIDParams) ([]Submission, error) {
	rows, err := q.db.QueryContext(ctx, getSubmissionsByProblemID, arg.ProblemID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submission
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.ProblemID,
			&i.UserID,
			&i.Language,
			&i.SourceCode,
			&i.Status,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByUserID = `-- name: GetSubmissionsByUserID :many
SELECT id, problem_id, user_id, language, source_code, status, updated_at, created_at FROM submissions WHERE user_id = $1 OFFSET $2 LIMIT $3
`

type GetSubmissionsByUserIDParams struct {
	UserID uuid.UUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetSubmissionsByUserID(ctx context.Context, arg GetSubmissionsByUserIDParams) ([]Submission, error) {
	rows, err := q.db.QueryContext(ctx, getSubmissionsByUserID, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submission
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.ProblemID,
			&i.UserID,
			&i.Language,
			&i.SourceCode,
			&i.Status,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubmissionResult = `-- name: UpdateSubmissionResult :one
UPDATE submission_results SET
    stdin = $2,
    stdout = $3,
    expected_output = $4,
    status_id = $5,
    time_used = $6,
    memory_used = $7,
    judge_response = $8,
    updated_at = now()
WHERE id = $1 RETURNING id, submission_id, judge_token, stdin, stdout, expected_output, status_id, time_used, memory_used, judge_response, updated_at, created_at
`

type UpdateSubmissionResultParams struct {
	ID             uuid.UUID
	Stdin          string
	Stdout         string
	ExpectedOutput string
	StatusID       int32
	TimeUsed       string
	MemoryUsed     float64
	JudgeResponse  []byte
}

func (q *Queries) UpdateSubmissionResult(ctx context.Context, arg UpdateSubmissionResultParams) (SubmissionResult, error) {
	row := q.db.QueryRowContext(ctx, updateSubmissionResult,
		arg.ID,
		arg.Stdin,
		arg.Stdout,
		arg.ExpectedOutput,
		arg.StatusID,
		arg.TimeUsed,
		arg.MemoryUsed,
		arg.JudgeResponse,
	)
	var i SubmissionResult
	err := row.Scan(
		&i.ID,
		&i.SubmissionID,
		&i.JudgeToken,
		&i.Stdin,
		&i.Stdout,
		&i.ExpectedOutput,
		&i.StatusID,
		&i.TimeUsed,
		&i.MemoryUsed,
		&i.JudgeResponse,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateSubmissionResultStatus = `-- name: UpdateSubmissionResultStatus :one
UPDATE submission_results SET
    status_id = $2,
    updated_at = now()
WHERE id = $1 RETURNING id, submission_id, judge_token, stdin, stdout, expected_output, status_id, time_used, memory_used, judge_response, updated_at, created_at
`

type UpdateSubmissionResultStatusParams struct {
	ID       uuid.UUID
	StatusID int32
}

func (q *Queries) UpdateSubmissionResultStatus(ctx context.Context, arg UpdateSubmissionResultStatusParams) (SubmissionResult, error) {
	row := q.db.QueryRowContext(ctx, updateSubmissionResultStatus, arg.ID, arg.StatusID)
	var i SubmissionResult
	err := row.Scan(
		&i.ID,
		&i.SubmissionID,
		&i.JudgeToken,
		&i.Stdin,
		&i.Stdout,
		&i.ExpectedOutput,
		&i.StatusID,
		&i.TimeUsed,
		&i.MemoryUsed,
		&i.JudgeResponse,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateSubmissionStatus = `-- name: UpdateSubmissionStatus :one
UPDATE submissions SET
    status = $2,
    updated_at = now()
WHERE id = $1 RETURNING id, problem_id, user_id, language, source_code, status, updated_at, created_at
`

type UpdateSubmissionStatusParams struct {
	ID     uuid.UUID
	Status string
}

func (q *Queries) UpdateSubmissionStatus(ctx context.Context, arg UpdateSubmissionStatusParams) (Submission, error) {
	row := q.db.QueryRowContext(ctx, updateSubmissionStatus, arg.ID, arg.Status)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.UserID,
		&i.Language,
		&i.SourceCode,
		&i.Status,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
